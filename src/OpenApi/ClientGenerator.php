<?php

namespace Picqer\BolRetailerV10\OpenApi;

use Exception;

class ClientGenerator
{
    protected $specs;

    protected static $overrideMethodNames = [
        'postShippingLabel' => 'createShippingLabel',
        'postInbound' => 'createInbound'
    ];

    protected static $overrideEnumNames = [
        '>=' => 'GTE',
        '<=' => 'LTE',
        '>' => 'GT',
        '<' => 'LT',
    ];

    protected static $paramTypeMapping = [
        'array' => 'array',
        'string' => 'string',
        'boolean' => 'bool',
        'integer' => 'int',
        'float' => 'float',
        'number' => 'float',
    ];

    public function __construct()
    {
        $retailer = (new SwaggerSpecs())->load(__DIR__ . '/retailer.json')
            ->merge((new SwaggerSpecs())->load(__DIR__ . '/shared.json'));
        $this->specs = $retailer->getSpecs();
    }

    public static function run()
    {
        $generator = new static;
        $generator->generateClient();
    }

    public function generateClient()
    {
        $code = [];
        $code[] = '<?php';
        $code[] = '';
        $code[] = sprintf('namespace %s;', $this->getClientNamespace());
        $code[] = '';
        $code[] = '// This class is auto generated by OpenApi\ClientGenerator';
        $code[] = 'class Client extends BaseClient';
        $code[] = '{';

        foreach ($this->specs['paths'] as $path => $methodsDef) {
            foreach ($methodsDef as $method => $methodDef) {
                $this->generateMethod($path, $method, $code);
            }
        }
        $code[] = '}';
        $code[] = '';

        file_put_contents(__DIR__ . '/../Client.php', implode("\n", $code));
    }

    protected function generateMethod(string $path, string $httpMethod, array &$code): void
    {
        $methodDefinition = $this->specs['paths'][$path][$httpMethod];

        echo "{$methodDefinition['operationId']}...";

        $returnType = $this->getReturnType($methodDefinition['responses']);

        if ($returnType === null) {
            echo "unsupported returnType\n";
            return;
        }

        $methodName = $this->getMethodName($methodDefinition['operationId']);
        $arguments = $this->extractArguments($methodDefinition);

        $nullableReturnType = false;
        if (isset($methodDefinition['responses']['404'])) {
            $nullableReturnType = true;
            if (! isset($returnType['property'])) {
                $returnType['doc'] = $returnType['doc'] . '|null';
                $returnType['php'] = '?' . $returnType['php'];
            }
        }

        $argumentsList = $this->getArgumentsList($arguments);

        $code[] = '';
        $code[] = '    /**';
        $code[] = $this->wrapComment($methodDefinition['description'], '     * ');
        $this->addParamsPhpDoc($arguments, $code);
        $code[] = sprintf('     * @return %s', $returnType['doc']);
        $code[] = '     * @throws Exception\ConnectException when an error occurred in the HTTP connection.';
        $code[] = '     * @throws Exception\ResponseException when an unexpected response was received.';
        $code[] = '     * @throws Exception\UnauthorizedException when the request was unauthorized.';
        $code[] = '     * @throws Exception\RateLimitException when the throttling limit has been reached for the API user.';
        $code[] = '     * @throws Exception\Exception when something unexpected went wrong.';
        $code[] = '     */';
        $code[] = sprintf('    public function %s(%s): %s', $methodName, $argumentsList, $returnType['php']);
        $code[] = '    {';
        $code[] = sprintf('        $url = "%s";', $this->getUrl($path, $arguments));

        $options = '[]';
        $code[] = '        $options = [';
        $this->addQueryParams($arguments, $code);
        $this->addBodyParam($arguments, $code);
        $this->addFormData($arguments, $code);

        $responseContent = $methodDefinition['responses']['200']['content'] ?? $methodDefinition['responses']['202']['content'] ?? $methodDefinition['responses']['400']['content'] ?? null;
        $code[] = sprintf('            \'produces\' => \'%s\',', array_key_first($responseContent));

        if ($methodDefinition['requestBody']['content'] ?? false) {
            $code[] = sprintf('            \'consumes\' => \'%s\',', array_key_first($methodDefinition['requestBody']['content']));
        }

        $code[] = '        ];';
        $options = '$options';

        $this->addResponseTypes($methodDefinition['responses'], $code);

        $code[] = '';
        if (isset($returnType['property']) && $nullableReturnType) {
            $code[] = sprintf(
                '        $result = $this->request(\'%s\', $url, %s, $responseTypes);',
                strtoupper($httpMethod),
                $options
            );
            $code[] = sprintf(
                '        return $result === null ? [] : $result->%s;',
                $returnType['property']
            );
        } elseif (isset($returnType['property'])) {
            $code[] = sprintf(
                '        return $this->request(\'%s\', $url, %s, $responseTypes)->%s;',
                strtoupper($httpMethod),
                $options,
                $returnType['property']
            );
        } else {
            $code[] = sprintf(
                '        return $this->request(\'%s\', $url, %s, $responseTypes);',
                strtoupper($httpMethod),
                $options
            );
        }

        $code[] = '    }';

        echo "ok\n";
    }

    protected function getType(string $ref): string
    {
        //strip #/components/schemas/
        $type = substr($ref, strrpos($ref, '/') + 1);

        // There are some weird types like 'delivery windows for inbound shipments.', uppercase and concat
        $type = str_replace(['.', ','], '', $type);
        $words = explode(' ', $type);
        $words = array_map(function ($word) {
            return ucfirst($word);
        }, $words);
        $type = implode('', $words);

        // Classname 'Return' is not allowed in php <= 7
        if ($type == 'Return') {
            $type = 'ReturnObject';
        }

        return $type;
    }

    protected function getClientNamespace(): string
    {
        return substr(__NAMESPACE__, 0, strrpos(__NAMESPACE__, '\\'));
    }

    protected function getMethodName(string $operationId): string
    {
        $methodName = $this->kebabCaseToCamelCase($operationId);
        if (isset(static::$overrideMethodNames[$methodName])) {
            return static::$overrideMethodNames[$methodName];
        }
        return $methodName;
    }

    protected function addParamsPhpDoc(array $arguments, array &$code): void
    {
        // TODO break at 120 chars
        foreach ($arguments as $argument) {
            if (empty($argument['description'])) {
                $code[] = sprintf(
                    '     * @param %s $%s',
                    $argument['doc'],
                    $argument['name']
                );
            } else {
                $code[] = $this->wrapComment(sprintf(
                    '@param %s $%s %s',
                    $argument['doc'],
                    $argument['name'],
                    $argument['description']
                ), '     * ');
            }
        }
    }

    protected function kebabCaseToCamelCase(string $name): string
    {
        // Fix for bug in specs where name contains spaces (e.g. 'get packing list')
        $name = str_replace(' ', '-', $name);

        $nameElems = explode('-', $name);
        for ($i = 1; $i < count($nameElems); $i++) {
            $nameElems[$i] = ucfirst($nameElems[$i]);
        }
        return implode('', $nameElems);
    }

    protected function getUrl(string $path, array $arguments): string
    {
        $url = substr($path, strlen('/'));

        foreach ($arguments as $argument) {
            if ($argument['in'] != 'path') {
                continue;
            }

            $url = str_replace(
                '{' . $argument['paramName'] . '}',
                '{$' . $argument['name'] . '}',
                $url
            );
        }

        return $url;
    }

    protected function extractArguments(array $methodDefinition): array
    {
        $argsWithoutDefault = [];
        $argsWithDefault = [];

        foreach ($methodDefinition['parameters'] ?? [] as $parameter) {
            $argument = [
                'default' => null,
                'description' => $parameter['description'] ?? null,
                'in' => $parameter['in'],
                'paramName' => null,
                'required' => $parameter['required']
            ];

            if ($parameter['in'] == 'query' && isset($parameter['schema']['$ref'])) {
                continue;
            } elseif ($parameter['in'] == 'query' && isset($parameter['schema']['enum'])) {
                $wrappingType = ucfirst($this->kebabCaseToCamelCase($methodDefinition['operationId'] . '-' . $parameter['name']));
                $argument['php'] = 'Enum\\' . $wrappingType;
                $argument['doc'] = $argument['php'];
                $argument['name'] = $this->kebabCaseToCamelCase($parameter['name']);
                $argument['paramName'] = $parameter['name'];
            } else {
                $argument['php'] = static::$paramTypeMapping[$parameter['schema']['type']];
                $argument['doc'] = $argument['php'];
                $argument['name'] = $this->kebabCaseToCamelCase($parameter['name']);
                $argument['paramName'] = $parameter['name'];

                if (isset($parameter['schema']['default'])) {
                    if ($parameter['schema']['type'] == 'string') {
                        $defaultValue = str_replace(['\''], ['\\\''], $parameter['schema']['default']);
                        $argument['default'] = sprintf('\'%s\'', $defaultValue);
                    } else {
                        $argument['default'] = $parameter['schema']['default'];
                    }
                }
            }

            // body arguments are always required, even though specs claim not
            if (! $argument['required'] && $argument['in'] != 'body') {
                if ($argument['php'] == 'array') {
                    $argument['default'] = '[]';
                } else {
                    $argument['php'] = '?' . $argument['php'];
                    $argument['doc'] = $argument['doc'] . '|null';
                    if ($argument['default'] === null) {
                        $argument['default'] = 'null';
                    }
                }
            }

            if ($argument['default'] !== null) {
                $argsWithDefault[] = $argument;
            } else {
                $argsWithoutDefault[] = $argument;
            }
        }

        if (isset($methodDefinition['requestBody']['content']) && $requestBody = current($methodDefinition['requestBody']['content'])) {
            if (isset($requestBody['schema']['$ref'])) {
                $argument = [
                    'default' => null,
                    'description' => null,
                    'in' => 'body',
                    'paramName' => null,
                    'required' => $methodDefinition['requestBody']['required']
                ];

                //strip #/components/schemas/
                $ref = $requestBody['schema']['$ref'];
                $type = $this->getType($ref);
                $apiType = substr($ref, strrpos($ref, '/') + 1);

                // extract property if it's a model that wraps an array
                $refSchema = $this->specs['components']['schemas'][$apiType];
                if (count($refSchema['properties']) == 1) {
                    $property = array_keys($refSchema['properties'])[0];
                    $propSchema = $refSchema['properties'][$property];

                    if (isset($propSchema['type']) && $propSchema['type'] == 'array') {
                        $itemsType = $this->getType($propSchema['items']['$ref']);
                        $argument['doc'] = 'Model\\' . $itemsType . '[]';
                        $argument['php'] = 'array';
                    } elseif (isset($propSchema['type'])) {
                        $wrappingType = static::$paramTypeMapping[$propSchema['type']];
                        $argument['doc'] = $wrappingType;
                        $argument['php'] = $wrappingType;
                    } else {
                        $wrappingType = $this->getType($propSchema['$ref']);
                        $argument['doc'] = 'Model\\' . $wrappingType;
                        $argument['php'] = 'Model\\' . $wrappingType;
                    }
                    $argument['property'] = $property;
                    $argument['name'] = $property;
                    $argument['wrapperPhp'] = 'Model\\' . $type;
                }

                if (! isset($argument['property'])) {
                    $argument['php'] = 'Model\\' . $type;
                    $argument['doc'] = $argument['php'];
                    $argument['name'] = lcfirst($type);
                }

                $argsWithoutDefault[] = $argument;
            } else {
                foreach ($requestBody['schema']['properties'] as $propName => $property) {
                    $argument = [
                        'default' => null,
                        'description' => null,
                        'in' => 'formData',
                        'paramName' => null,
                        'required' => $methodDefinition['requestBody']['required']
                    ];

                    $argument['php'] = static::$paramTypeMapping[$property['type']];
                    $argument['doc'] = $argument['php'];
                    $argument['name'] = $this->kebabCaseToCamelCase($propName);
                    $argument['is_file'] = 'binary' === $property['format'];

                    $argsWithoutDefault[] = $argument;
                }
            }
        }

        return array_merge($argsWithoutDefault, $argsWithDefault);
    }

    protected function getArgumentsList(array $arguments): string
    {
        $argumentsList = [];

        foreach ($arguments as $argument) {
            if ($argument['default'] !== null) {
                $argumentsList[] = sprintf('%s $%s = %s', $argument['php'], $argument['name'], $this->argumentValueToString($argument['default']));
            } else {
                $argumentsList[] = sprintf('%s $%s', $argument['php'], $argument['name']);
            }
        }

        return implode(', ', $argumentsList);
    }

    protected function argumentValueToString($argument): string
    {
        if ($argument === true) {
            return 'true';
        } elseif ($argument === false) {
            return 'false';
        }

        return $argument;
    }

    protected function addQueryParams(array $arguments, array &$code): void
    {
        $amount = array_reduce($arguments, function ($amount, $argument) {
            return $argument['in'] == 'query' ? $amount + 1 : $amount;
        });

        if ($amount == 0) {
            return;
        }

        $code[] = '            \'query\' => [';

        foreach ($arguments as $argument) {
            if ($argument['in'] != 'query') {
                continue;
            }
            $code[] = sprintf('                \'%s\' => $%s%s,', $argument['paramName'], $argument['name'], str_starts_with($argument['php'], 'Enum') ? '->value' : (str_starts_with($argument['php'], '?Enum') ? '?->value' : ''));
        }
        $code[] = '            ],';
    }

    protected function addBodyParam(array $arguments, array &$code): void
    {
        foreach ($arguments as $argument) {
            if ($argument['in'] != 'body') {
                continue;
            }

            if (isset($argument['wrapperPhp'])) {
                $code[] = sprintf(
                    '            \'body\' => %s::constructFromArray([\'%s\' => $%s]),',
                    $argument['wrapperPhp'],
                    $argument['property'],
                    $argument['name']
                );
            } else {
                $code[] = sprintf('            \'body\' => $%s,', $argument['name']);
            }


            return;
        }
    }

    protected function addFormData(array $arguments, array &$code): void
    {
        $containsFileArgument = in_array(true, array_map(
            static fn(array $argument): bool => $argument['is_file'] ?? false,
            $arguments,
        ));
        $formData = [];

        foreach ($arguments as $argument) {
            if ($argument['in'] != 'formData') {
                continue;
            }

            if ($containsFileArgument) {
                $formData[] = '                [';
                $formData[] = sprintf('                    \'name\' => \'%s\',', $argument['name']);
                $formData[] = $argument['is_file']
                    ? sprintf('                    \'contents\' => \GuzzleHttp\Psr7\Utils::tryFopen($%s, \'r\'),', $argument['name'])
                    : sprintf('                    \'contents\' => $%s,', $argument['name']);
                $formData[] = '                ],';
            } else {
                $formData[] = sprintf('                \'%s\' => $%s,', $argument['name'], $argument['name']);
            }
        }

        if ($formData) {
            $code[] = $containsFileArgument
                ? '            \'multipart\' => ['
                : '            \'form_params\' => [';
            foreach ($formData as $argument) {
                $code[] = $argument;
            }
            $code[] = '            ],';
        }
    }

    protected function addResponseTypes(array $responses, array &$code): void
    {
        $code[] = '        $responseTypes = [';
        foreach ($responses as $httpStatus => $response) {
            $type = null;
            if (in_array($httpStatus, ['200', '202'])) {
                $response = current($response['content'] ?? []);

                if (! isset($response['schema'])) {
                    // There are 2 methods that return a csv, but have no response type defined
                    $type = '\'string\'';
                } elseif (isset($response['schema']['$ref'])) {
                    $type = 'Model\\' . $this->getType($response['schema']['$ref']) . '::class';
                } else {
                    $type = '\'string\'';
                }
            } elseif ($httpStatus == '404') {
                $type = '\'null\'';
            }
            if ($type !== null) {
                $code[] = sprintf('            \'%s\' => %s,', $httpStatus, $type);
            }
        }
        $code[] = '        ];';
    }

    protected function getReturnType(array $responses): array
    {
        $response = $responses['200'] ?? $responses['202'] ?? $responses['207'] ?? null;
        if ($response === null) {
            throw new Exception('Could not fit responseType: ' . print_r($responses, true));
        }

        $response = current($response['content'] ?? []);

        if (! isset($response['schema'])) {
            // There are 2 methods that return a csv, but have no response type defined
            return ['doc' => 'string', 'php' => 'string'];
        } elseif (isset($response['schema']['$ref'])) {
            //strip #/components/schemas/
            $ref = $response['schema']['$ref'];
            $apiType = substr($ref, strrpos($ref, '/') + 1);

            // extract property if it's a model that wraps an array
            $refSchema = $this->specs['components']['schemas'][$apiType];
            if (count($refSchema['properties']) == 1) {
                $property = array_keys($refSchema['properties'])[0];
                if (isset($refSchema['properties'][$property]['type'], $refSchema['properties'][$property]['items']['$ref']) && $refSchema['properties'][$property]['type'] == 'array') {
                    return [
                        'doc' => 'Model\\' . $this->getType(
                                $refSchema['properties'][$property]['items']['$ref']
                            ) . '[]',
                        'php' => 'array',
                        'property' => $property
                    ];
                }
            }

            $type = 'Model\\' . $this->getType($ref);
            return ['doc' => $type, 'php' => $type];
        } else {
            // currently only array is support

            if ($response['schema']['type'] != 'string' || $response['schema']['format'] != 'byte') {
                throw new Exception("Only Models and raw bytes are supported as response type");
            }
            return ['doc' => 'string', 'php' => 'string', ''];
        }
    }

    protected function getEnumName(string $name): string
    {
        $name = preg_replace('/[\-\s\/]+/', '_', $name);

        if (isset(static::$overrideEnumNames[$name])) {
            $name = static::$overrideEnumNames[$name];
        }

        // We add the first `_` for enums starting with a integer character
        $prefix = is_numeric($name[0]) ? '_' : '';

        return $prefix . strtoupper($name);
    }

    protected function wrapComment(string $comment, string $linePrefix, int $maxLength = 120): string
    {
        $wordWrapped = wordwrap(strip_tags($comment), $maxLength - strlen($linePrefix));
        return $linePrefix . trim(str_replace("\n", "\n{$linePrefix}", $wordWrapped));
    }
}
